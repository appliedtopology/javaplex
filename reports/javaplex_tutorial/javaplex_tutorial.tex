\documentclass[amscd, amssymb, verbatim]{amsart}[12pt]

\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{pb-diagram}
\usepackage[mathscr]{euscript}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{placeins}
\usepackage{wrapfig}
\usepackage{url}
\usepackage{appendix}
\usepackage{multind}

\theoremstyle{remark}
\newtheorem{exercise}{Exercise}[subsection]
\newcommand{\lc}{\lowercase}
\errorcontextlines=0
\newcommand{\comment}[1]{}

\setlength{\parindent}{0pt}

\begin{document}

\title{\lc{java}P\lc{lex} T\lc{utorial}}
\author{H\lc{enry} A\lc{dams and} A\lc{ndrew} T\lc{ausz} \\ \lc{henrya@math.stanford.edu and atausz@stanford.edu} \\ J\lc{une 17, 2011}}


\maketitle

% TODO: figure out where to put Snowbird datasets

% TODO: add flat torus and flat klein examples to tutorial.

% TODO: make pdf file for exercise solutions

% TODO: fix LaTeX style, as per meeting with Mikael

% how do you display the simplices in a stream?

% Change VR$(Z,t)$ to $\VR(Z,t)$ (and same for witness complexes) by defining new math operators.

\tableofcontents




\section{Introduction}


\subsection{javaPlex}

javaPlex is a Java software package for computing the persistent homology of filtered chain complexes, with special emphasis on applications arising in topological data analysis. The main author is Andrew Tausz. javaPlex is a re-write of the JPlex package, which was written by Harlan Sexton and Mikael Vejdemo Johansson. The main motivation for the development of javaPlex was the need for a flexible platform that supported new directions of research in topological data analysis and computational persistent homology. The website for javaPlex is \url{http://code.google.com/p/javaplex/} and the javadoc tree for the library is at \url{http://javaplex.googlecode.com/svn/trunk/doc/index.html}. \\

If you are interested in javaPlex, then you may also be interested in the software package Dionysus by Dmitriy Morozov, available at \url{http://www.mrzv.org/software/dionysus}. \\

Some of the exercises in this tutorial are borrowed from Vin de Silva's {\em Plexercises}, available at \url{http://comptop.stanford.edu/u/programs/Plexercises2.pdf}. \\


\subsection{License}

javaPlex is an open source software package under the Open BSD License. The source code can be found at \url{http://code.google.com/p/javaplex/}. If you are interested in contributing to the project, we invite you to contact either of the authors. \\


\subsection{Installation for Matlab}
Open Matlab and check which version of Java is being used. In this tutorial, the symbol \texttt{>>} precedes commands to enter into your Matlab window.
\begin{quote} \texttt{>> version -java \\
ans = Java 1.5.0\_13 with Apple Inc.   Java Hotspot(TM) Client VM mixed mode, sharing
} \end{quote}
javaPlex requires version number \texttt{1.5} or higher. \\

To install javaPlex for Matlab, go the the website \url{http://code.google.com/p/javaplex/downloads/list}. Download the zip file containing the Matlab examples. It should be called something like \texttt{matlab-examples\-4.01.tar.gz}. % TODO: this file is out of date
Extract the zip file. The resulting folder should be called \texttt{matlab-examples}. \\
% Or, go to folder javaplex/src/matlab/for_distribution

Change directories in Matlab  to \texttt{matlab-examples}. Run the \texttt{load\_javaplex.m} file. 
\begin{quote} \texttt{>> load\_javaplex
} \end{quote}
Installation is complete. Confirm that javaPlex is working properly with the following command.
\begin{quote} \texttt{ >> api.Plex4.createExplicitSimplexStream() \\
ans = edu.stanford.math.plex4.streams.impl.ExplicitSimplexStream@513fd4
} \end{quote}
Your output should be the same except for the last several characters. \\
 
Each time upon starting a new Matlab session, you will need to run \texttt{load\_javaplex.m}. \\


\subsection{Accompanying files}

The following Matlab scripts containing the commands in this tutorial are available in the folder \texttt{matlab\_examples/tutorial\_examples}. This means that you don't need to type in each command individually.
\begin{itemize}
\item \texttt{core\_subsets\_example.m}
\item \texttt{euler\_characteristic\_example.m}
\item \texttt{explicit\_metric\_space\_example.m}
\item \texttt{explicit\_simplex\_example.m}
\item \texttt{house\_example.m}
\item \texttt{image\_patch\_example.m}
\item \texttt{landmark\_example.m}
\item \texttt{lazy\_witness\_example.m}
\item \texttt{pointcloud\_example.m}
\item \texttt{rips\_example.m}
\item \texttt{witness\_example.m}
\end{itemize}
The folder \texttt{matlab\_examples/tutorial\_examples} also contains the following Matlab functions
\begin{itemize}
\item \texttt{coreSubset.m}
\item \texttt{dct.m}
\item \texttt{eulerCharacteristic.m}
\end{itemize}
and the following Matlab data files
\begin{itemize}
\item \texttt{pointsRange.mat}
\item \texttt{pointsTorusGrid.mat}
\end{itemize}
which are used in this tutorial. \\

The folder \texttt{matlab\_examples/tutorial\_solutions} contains the following solution scripts to tutorial exercises.
\begin{itemize}
\item \texttt{exercise\_3\_1\_1.m}
\item \texttt{exercise\_3\_1\_2.m}
\item \texttt{exercise\_3\_1\_3.m}
\item \texttt{exercise\_5\_1\_2.m}
\item \texttt{exercise\_5\_1\_3.m}
\end{itemize}
% TODO: add solutions pdf when it gets made.




\section{Math review}

Below is a brief math review. For more details, see \cite{a83, eh10, h02, zc05}. \\


\subsection{Simplicial complexes}
An abstract simplicial complex is given by the following data.
\begin{itemize}
\item A set $Z$ of vertices or 0-simplices.
\item For each $k\geq 1$, a set of $k$-simplices $\sigma = [z_0z_1...z_k]$, where $z_i\in Z$.
\item Each $k$-simplex has $k+1$ faces obtained by deleting one of the vertices. The following membership property must be satisfied: if $\sigma$ is in the simplicial complex, then all faces of $\sigma$ must be in the simplicial complex.
\end{itemize}
We think of 0-simplices as vertices, 1-simplices as edges, 2-simplices as triangular faces, and 3-simplices as tetrahedrons. \\


\subsection{Homology}
Betti numbers help describe the homology of a simplicial complex $X$. The value $Betti_k$, where $k\in \mathbb{N}$, is equal to the rank of the $k$-th homology group of $X$. Roughly speaking, $Betti_k$ gives the number of $k$-dimensional holes. In particular, $Betti_0$ is the number of connected components. For instance, a $k$-dimensional sphere has all Betti numbers equal to zero except for $Betti_0 = Betti_k = 1$. \\


\subsection{Filtered simplicial complexes}
A filtration on a simplicial complex $X$ is a collection of subcomplexes $\{X(t) \ |\ t\in \mathbb{R}\}$ of $X$ such that $X(t) \subset X(s)$ whenever $t\leq s$. The filtration time of a simplex $\sigma \in X$ is the smallest $t$ such that $\sigma \in X(t)$. In javaPlex, filtered simplicial complexes (or more generally filtered chain complexes) are called streams. \\
% Introduce filtered chain complexes?


\subsection{Persistent homology}
Betti intervals help describe how the homology of $X(t)$ changes with $t$. A $k$-dimensional Betti interval, with endpoints [$t_{start}$, $t_{end}$), corresponds roughly to a $k$-dimensional hole that appears at filtration time $t_{start}$, remains open for $t_{start} \leq t < t_{end}$, and closes at time $t_{end}$. We are often interested in Betti intervals that persist for a long filtration range. \\

Persistent homology depends heavily on functoriality: for $t\leq s$, the inclusion $i:X(t)\to X(s)$ of simplicial complexes induces a map $i_*:H_k(X(t))\to H_k(X(s))$ between homology groups. \\




\section{Explicit simplex streams}\label{explicitStream}

In javaPlex, filtered simplicial complexes (or more generally filtered chain complexes) are called streams. The class ExplicitSimplexStream allows one to build a simplicial complex from scratch. In Section \ref{sfpc} we will learn about other automated methods of generating simplicial complexes; namely the Vietoris--Rips, witness, and lazy witness constructions. 


\subsection{Explicit simplex streams and homology}

The Matlab script corresponding to this section is \\ %overflow
\texttt{explicit\_simplex\_example.m}, which is in the folder \texttt{tutorial\_examples}. You may copy and paste commands from this script into the Matlab window, or you may run the entire script at once with the following command.
\begin{quote} \texttt{>> explicit\_simplex\_example\\
} \end{quote}



{\em Circle example.} Let's build a simplicial complex homeomorphic to a circle. We have three 0-simplices: [0], [1], [2], and three 1-simplices: [0,1], [0,2], [1,2].

\hspace{2.5in}\includegraphics[height=1in]{s1.pdf}

To build a simplicial complex in javaPlex we simply build a stream in which all filtration times are zero. First we create an empty explicit simplex stream. Many command lines in this tutorial will end with a semicolon to supress unwanted output.
\begin{quote} \texttt{>> stream = api.Plex4.createExplicitSimplexStream();
} \end{quote}

Next we add simplicies using the methods \texttt{addVertex} and \texttt{addElement}. The first creates a vertex with a specified index, and the second creates a $k$-simplex (for $k >0$) with the specified array of vertices. Since we don't specify any filtration times, by default all added simplices will have filtration time zero.

\begin{quote}\texttt{>> stream.addVertex(0);\\
>> stream.addVertex(1); \\
>> stream.addVertex(2); \\
>> stream.addElement([0, 1]); \\
>> stream.addElement([0, 2]); \\
>> stream.addElement([1, 2]);
} \end{quote}

We print the total number of simplices in the complex.
\begin{quote}\texttt{>> num\_simplices = stream.getSize() \\
num\_simplices = 6\\
} \end{quote}

In order to compute the homology of our complex, we first create an object that will perform the computation. The following line obtains the default algorithm for performing simplicial homology. There are other variants on the persistence algorithm, and one can also change the ground field. This default object will perform the homology computation with $\mathbb{Z}_2$ coefficients. The input parameter 3 indicates that homology will be computed in dimensions 0, 1, and 2 --- that is, in all dimensions strictly less than 3.
\begin{quote}\texttt{>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(3);
} \end{quote}
We compute and print the intervals.
\begin{quote} \texttt{>> circle\_intervals = persistence.computeIntervals(stream) \\
circle\_intervals = \\
\\
Dimension: 1 \newline
[0, infinity) \\
Dimension: 0 \newline
[0, infinity)
} \end{quote}
This gives us the expected Betti numbers $Betti_0=1$ and $Betti_1=1$. \\

{\em 9-sphere example.} Let's build a 9-sphere, which is homeomorphic to the boundary of a 10-simplex. First we add a single 10-simplex to an empty explicit simplex stream. The result is not a simplicial complex because it does not contain the faces of the 10-simplex. We add all faces using the method \texttt{ensureAllFaces}. Then, we remove the 10-simplex using the method \texttt{removeElementIfPresent}. What remains is the boundary of a 10-simplex, that is, a 9-sphere.

\begin{quote} \texttt{>> dimension = 9; \\
>> stream = api.Plex4.createExplicitSimplexStream(); \\
>> stream.addElement(0:(dimension + 1)); \\
>> stream.ensureAllFaces(); \\
>> stream.removeElementIfPresent(0:(dimension + 1)); \\
>> stream.finalizeStream();
}\end{quote}

In the above, the \texttt{finalizeStream} function is used to ensure that the stream has been fully constructed and is ready for consumption by a persistence algorithm. Note that it can be omitted in the case where the simplex additions are done in increasing order. However, it should be used in general. \\

We print the total number of simplices in the complex.
\begin{quote} \texttt{>> num\_simplices = stream.getSize()\\
num\_simplices = 2046
}\end{quote}

We get the default persistence computation
\begin{quote} \texttt{>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(dimension + 1);
}\end{quote}
and compute and print the intervals.
\begin{quote} \texttt{>> n\_sphere\_intervals = persistence.computeIntervals(stream) \\
n\_sphere\_intervals = \\
\\
Dimension: 9\newline
[0, infinity)\\
Dimension: 0\newline
[0, infinity)
} \end{quote}
This gives us the expected Betti numbers $Betti_0=1$ and $Betti_9=1$. \\

\begin{exercise}
Build a simplicial complex homeomorphic to the torus. Compute its Betti numbers. {\em Hint:} You will need at least 7 vertices \cite[page 107]{h02}. We recommend using a $3\times 3$ grid of 9 vertices. \\
\end{exercise}

\begin{exercise}
Build a simplicial complex homeomorphic to the Klein bottle. Check that it has the same Betti numbers as the torus over $\mathbb{Z}_2$ coefficients but different Betti numbers over $\mathbb{Z}_3$ coefficients. \\
\end{exercise}

\begin{exercise}
Build a simplicial complex homeomorphic to the projective plane. Find its Betti numbers over $\mathbb{Z}_2$ and $\mathbb{Z}_3$ coefficients. \\
\end{exercise}


\subsection{Explicit simplex streams and persistent homology}\label{explicitStreamPers}

Let's build a stream with nontrivial filtration times. \\

{\em House example.} The Matlab script corresponding to this section is \texttt{house\_example.m}.\\

\begin{wrapfigure}{r}{1in}
	\begin{center}
   	\includegraphics[width=1in]{house}
  	\end{center}
\end{wrapfigure}
% figure is very pixelated

We build a house, with the vertices and edges on the square appearing at time 0, with the top vertex appearing at time 1, with the roof edges appearing at times 2 and 3, and with the roof 2-simplex appearing at time 7.
\begin{quote} \texttt{>> stream = api.Plex4.createExplicitSimplexStream(); \\
>> stream.addVertex(1, 0); \\
>> stream.addVertex(2, 0); \\
>> stream.addVertex(3, 0); \\
>> stream.addVertex(4, 0); \\
>> stream.addVertex(5, 1); \\
>> stream.addElement([1, 2], 0); \\
>> stream.addElement([2, 3], 0); \\
>> stream.addElement([3, 4], 0); \\
>> stream.addElement([4, 1], 0); \\
>> stream.addElement([3, 5], 2); \\
>> stream.addElement([4, 5], 3); \\
>> stream.addElement([3, 4, 5], 7);
} \end{quote}
We get the default persistence computation,
\begin{quote} \texttt{>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(3);
} \end{quote}
compute the intervals,
\begin{quote} \texttt{>> filtration\_index\_intervals = persistence.computeIntervals(stream);
} \end{quote}
and transform the integral intervals to floating point intervals.
\begin{quote} \texttt{>> transformer = homology.filtration.IdentityConverter.getInstance(); \\
>> filtration\_value\_intervals = transformer.transform(filtration\_index\_intervals) \\
filtration\_value\_intervals =\\
\\
Dimension: 1\newline
[3.0, 7.0)\newline
[0.0, infinity)\\
Dimension: 0\newline
[1.0, 2.0)\newline
[0.0, infinity)\\
} \end{quote}
There are four intervals. The first is a $Betti_1$ interval, starting at filtration time 3 and ending at 7. This 1-dimensional hole is formed by the three edges of the roof. It forms when edge $[4,5]$ appears at filtration time 3 and closes when 2-simplex $[3,4,5]$ appears at filtration time 7.\\

One $Betti_0$ interval and one $Betti_1$ interval are semi-infinite. 
\begin{quote} \texttt{>> infinite\_barcodes = filtration\_value\_intervals.getInfiniteIntervals();
} \end{quote}
We can print the Betti numbers (at the largest filtration time 7) as an array
\begin{quote} \texttt{>> betti\_numbers\_array = infinite\_barcodes.getBettiSequence()
} \end{quote}
\hspace{12mm}\texttt{betti\_numbers\_array =}

\hspace{19mm}$\begin{matrix}
\texttt{1}\\
\texttt{1}
\end{matrix}$
\vspace{3mm}

or as a list with entries of the form $k: Betti_k$.
\begin{quote} \texttt{>> betti\_numbers\_string = infinite\_barcodes.getBettiNumbers()\\
betti\_numbers\_string = \{0: 1, 1: 1\} \\
} \end{quote}

The method \texttt{createBarcodePlot} lets us display the intervals as a Betti barcode. The three inputs are \texttt{filtration\_value\_intervals}, a string for the filename, and the maximum filtration time for the plot. 
\begin{quote} \texttt{>> api.Plex4.createBarcodePlot(filtration\_value\_intervals, 'house', 8)
} \end{quote}
The files \texttt{house\_0.PNG} and \texttt{house\_1.PNG} are saved to your current directory.

\begin{figure}[htp]
  \begin{center}
    \subfigure{\includegraphics[width=6in]{house_0}}
    \subfigure{\includegraphics[width=6in]{house_1}}
   \end{center}
\end{figure}
\FloatBarrier

The filtration times are on the horizontal axis. The $Betti_k$ number of the stream at filtration time $t$ is the number of intervals in the dimension $k$ plot that intersect a vertical line through $t$. Check that the displayed intervals agree with the filtration times we built into the house stream. At time 0, a connected component and a 1-dimensional hole form. At time 1, a second connected component appears, which joins to the first at time 2. A second 1-dimensional hole forms at time 3, and closes at time 7. \\

An important remark is that the methods \texttt{addElement} and \texttt{removeElementIfPresent} do not necessarily enforce the definition of a stream. They allow us to build inconsistent complexes in which some simplex $\sigma \in X(t)$ contains a subsimplex $\sigma' \notin X(t)$, meaning that $X(t)$ is not a simplicial complex. The method \texttt{validateVerbose} returns \texttt{1} if our stream is consistent and returns \texttt{0} with explanation if not. 
\begin{quote} \texttt{>> stream.validateVerbose() \\
ans = 1 \\
>> stream.addElement([1, 4, 5], 0); \\
>> stream.validateVerbose() \\
Filtration index of face [4,5] exceeds that of element [1,4,5] (3 > 0) \\
Stream does not contain face [1,5] of element [1,4,5] \\
ans = 0\\
} \end{quote}

%In Section \ref{sfpc} we will create simplex streams that are not also explicit simplex streams. To display or edit such streams, we will first need to use the method \texttt{makeExplicit}. See Exercise \ref{ripsExpl}. \\
% TODO

% Henry: At the moment there is no ``make Explicit'' function. 




\section{Point cloud data}

A point cloud is a finite metric space, that is, a finite set of points equipped with a notion of distance. One can create a Euclidean metric space by specifying the coordinates of points in Euclidean space, or one can create an explicit metric space by specifying all pairwise distances between points. In Section \ref{sfpc} we will learn how to build streams from point cloud data. \\


\subsection{Euclidean metric spaces}\label{euc} The Matlab script corresponding to this section is \texttt{pointcloud\_example.m}. \\

{\em House example.} Let's give Euclidean coordinates to the points of our house.

\vspace{-3mm}
\begin{figure}[htb]
	\centering
	\includegraphics[width=1.55in]{houseCoord}
	\vspace{-3mm}
	\caption{The house point cloud}
	\label{fig:housePointCloud}
\end{figure}
\FloatBarrier
% figure is pixelated

You can enter these coordinates manually.
\begin{quote} \texttt{>> point\_cloud = [-1,0; 1,0; 1,2; -1,2; 0,3]} \end{quote}
\hspace{12mm}\texttt{point\_cloud =}

\hspace{19mm}$\begin{matrix}
\texttt{-1} && \texttt{0}\\
\texttt{ 1} && \texttt{0}\\
\texttt{ 1} && \texttt{2}\\
\texttt{-1} && \texttt{2}\\
\texttt{ 0} && \texttt{3}\\
\end{matrix}$
\vspace{3mm}

Or, these coordinates are stored as a javaPlex example.
\begin{quote} \texttt{>> point\_cloud = examples.PointCloudExamples.getHouseExample();\\} \end{quote}

We create a metric space using these coordinates. The input to the \texttt{EuclideanMetricSpace} method is a matrix whose $i$-th row lists the coordinates of the $i$-th point.
\begin{quote} \texttt{>> m\_space = metric.impl.EuclideanMetricSpace(point\_cloud);} \end{quote}
We can return the coordinates of a specific point. Note the points are indexed starting at 0.
\begin{quote} \texttt{>> m\_space.getPoint(0)} \end{quote}
\hspace{12mm}\texttt{ans =}

\hspace{19mm}$\begin{matrix}
\texttt{-1}\\
\texttt{ 0}
\end{matrix}$

\begin{quote} \texttt{>> m\_space.getPoint(2)} \end{quote}
\hspace{12mm}\texttt{ans =}

\hspace{19mm}$\begin{matrix}
\texttt{ 1}\\
\texttt{ 2}
\end{matrix}$

A metric space can return the distance between any two points.
\begin{quote} \texttt{>> m\_space.distance(m\_space.getPoint(0), m\_space.getPoint(2))\\
ans = 2.8284\\
} \end{quote}

{\em Figure 8 example.} We select 1,000 points randomly from a figure eight, that is, the union of unit circles centered at $(0,1)$ and $(0,-1)$.
\begin{quote} \texttt{>> point\_cloud = examples.PointCloudExamples.getRandomFigure8Points(1000);
} \end{quote}
We plot the points.
\begin{quote} \texttt{>> figure\\
>> plot(point\_cloud(:,1), point\_cloud(:,2), '.')\\
>> axis equal\\
} \end{quote}

{\em Torus example.} We select 2,000 points randomly from a torus in $\mathbb{R}^3$ with inner radius 1 and outer radius 2. The first input is the number of points, the second input is the inner radius, and the third input is the outer radius
\begin{quote} \texttt{>> point\_cloud = examples.PointCloudExamples.getRandomTorusPoints(2000, 1, 2);
} \end{quote}
We plot the points.
\begin{quote} \texttt{>> figure\\
>> plot3(point\_cloud(:,1), point\_cloud(:,2), point\_cloud(:,3), '.')\\
>> axis equal\\
} \end{quote}

{\em Sphere product example.} We select 1,000 points randomly from the unit torus $S^1 \times S^1$ in $\mathbb{R}^4$. The first input is the number of points, the second input is the dimension of each sphere, and the third input is the number of sphere factors.
\begin{quote} \texttt{>> point\_cloud = examples.PointCloudExamples.getRandomTorusPoints(1000, 1, 2);
} \end{quote}
Plotting the third and fourth coordinates of each point shows a circle $S^1$.
\begin{quote} \texttt{>> figure\\
>> plot(point\_cloud(:,3), point\_cloud(:,4), '.')\\
>> axis equal\\
} \end{quote}


\subsection{Explicit metric spaces}
We can also create a metric space from a distance matrix using the method \texttt{ExplicitMetricSpace}. For a point cloud in Euclidean space, this method is generally less convenient than the command \texttt{EuclideanMetricSpace}. However, method \texttt{ExplicitMetricSpace} can be used for a point cloud in an arbitrary (perhaps non-Euclidean) metric space. \\

The Matlab script corresponding to this section is \texttt{explicit\_metric\_space\_example.m}. \\

{\em House example.} The matrix \texttt{distances} summarizes the metric for our house points in Figure \ref{fig:housePointCloud}: entry $(i,j)$ is the distance from point $i$ to point $j$. \\

\hspace{8mm}\texttt{>> distances = [0,2,sqrt(8),2,sqrt(10);}

\hspace{15mm}\texttt{2,0,2,sqrt(8),sqrt(10);}

\hspace{15mm}\texttt{sqrt(8),2,0,2,sqrt(2);}

\hspace{15mm}\texttt{2,sqrt(8),2,0,sqrt(2);}

\hspace{15mm}\texttt{sqrt(10),sqrt(10),sqrt(2),sqrt(2),0]}

\vspace{5mm}
\hspace{8mm}\texttt{distances =}\\

\hspace{15mm}$\begin{matrix}
\texttt{0} & \texttt{2.0000} & \texttt{2.8284} & \texttt{2.0000} & \texttt{3.1623}\\
\texttt{2.0000} & \texttt{0} & \texttt{2.0000} & \texttt{2.8284} & \texttt{3.1623}\\
\texttt{2.8284} & \texttt{2.0000} & \texttt{0} & \texttt{2.0000} & \texttt{1.4142}\\
\texttt{2.0000} & \texttt{2.8482} & \texttt{2.0000} & \texttt{0} & \texttt{1.4142}\\
\texttt{3.1623} & \texttt{3.1623} & \texttt{1.4142} & \texttt{1.4142} & \texttt{0}
\end{matrix}$
\vspace{3mm}

We create a metric space from this distance matrix. 
\begin{quote} \texttt{>> m\_space = metric.impl.ExplicitMetricSpace(distances);
} \end{quote}
We return the distance between points 0 and 2.
\begin{quote} \texttt{>> m\_space.distance(0, 2) \\
ans = 2.8284 \\
} \end{quote}

% Be careful: the constructor \texttt{DistanceData()} will accept matrices that fail to be symmetric, square, or nonnegative, creating ``metrics'' that do not satisfy the mathematical definiton. The triangle inequality is similarly easy to ignore. However, asking for the distance between a point and itself will always return zero, even if you input a distance matrix with non-zero diagonal entries. \\




\section{Streams from point cloud data}\label{sfpc}

In Section \ref{explicitStream} we built streams explicitly, or by hand. In this section we construct streams from a point cloud $Z$. We build Vietoris--Rips, witness, and lazy witness streams. See \cite{dsc04} for additional information. \\

The Vietoris--Rips, witness, and lazy witness streams all take three of the same inputs: the maximum dimension $d_{max}$, the maximum filtration time $t_{max}$, and the number of divisions $N$. These inputs allow the user to limit the size of the constructed stream, for computational efficiency. No simplices above dimension $d_{max}$ are included. The persistent homology of the resulting stream can be calculated only up to dimension $d_{max} - 1$ (do you see why?). Also, instead of computing complex $X(t)$ for all $t \geq 0$, we only compute $X(t)$ for
$$t \in \Biggl\{ 0,\ \frac{t_{max}}{N-1},\ \frac{2t_{max}}{N-1},\ \frac{3t_{max}}{N-1},\ \dots,\ \frac{(N-2)t_{max}}{N-1},\ t_{max} \Biggr\}.$$
The number of divisions $N$ is an optional input. If this input parameter is not specified, then the default value $N = 20$ is used. \\

When working with a new dataset, don't choose $d_{max}$ and $t_{max}$ too large initially. First get a feel for how fast the simplicial complexes are growing, and then raise $d_{max}$ and $t_{max}$ nearer to the computational limits. If you ever choose $d_{max}$ or $t_{max}$ too large and Matlab seems to be running forever, pressing the \texttt{control} and \texttt{c} buttons simultaneously may halt the computation. \\

%The first author is currently working with Jan Segert on interactive visualizations of the Vietoris--Rips and Witness filtrations for the Wolfram Demonstrations Project. We have preliminary drafts of the demonstrations. Please email Henry if you'd like to check them out; in particular, the witness filtrations can be hard to visualize. \\


\subsection{Vietoris--Rips streams}\label{Vietoris--Rips}
Let  $d(\ \cdot\ ,\ \cdot \ )$ denote the distance between two points in metric space $Z$. A natural stream to build is the Vietoris--Rips stream. The complex VR$(Z,t)$ is defined as follows: 
\begin{itemize}
\item{the vertex set is $Z$.}
\item{for vertices $a$ and $b$, edge $[ab]$ is in VR$(Z,t)$ if $d(a,b) \leq t$.}
\item{a higher dimensional simplex is in VR$(Z,t)$ if all of its edges are.}
\end{itemize}
Note that $\mbox{VR}(Z,t) \subset \mbox{VR}(Z,s)$ whenever $t\leq s$, so the Vietoris--Rips stream is a filtered simplicial complex. Since a Vietoris--Rips complex is the maximal simplicial complex that can be built on top of its 1-skeleton, it is a {\em flag complex}. \\

The Matlab script corresponding to this section is \texttt{rips\_example.m}. \\

{\em House example.} Let's build a Vietoris--Rips stream from the house point cloud in Section \ref{euc}. Note this stream is different than the explicit house stream we built in Section \ref{explicitStreamPers}.
\begin{quote} \texttt{>> max\_dimension = 3; \\
>> max\_filtration\_value = 4; \\
>> num\_divisions = 100; \\
\\
>> point\_cloud = examples.PointCloudExamples.getHouseExample(); \\
>> stream = api.Plex4.createVietorisRipsStream(point\_cloud, max\_dimension, \\ % overflow
max\_filtration\_value, num\_divisions);
} \end{quote}
The order of the inputs is \texttt{createVietorisRipsStream(}$Z,\ d_{max},\ t_{max},\ N$\texttt{)}. For a Vietoris--Rips stream, the parameter $t_{max}$ is the maximum possible edge length. Since $t_{max} = 4$ is greater than the diameter ($\sqrt{10}$) of our point cloud, all edges will eventually form. \\

Since $d_{max} = 3$ we can compute up to second dimensional persistent homology. 
\begin{quote} \texttt{>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(max\_dimension); \\
>> filtration\_index\_intervals = persistence.computeIntervals(stream); \\
>> filtration\_value\_intervals = stream.transform(filtration\_index\_intervals);
} \end{quote}
We display the Betti intervals. Typically the last input for the method \texttt{createBarcodePlot} will be $t_{max}$, since there is no reason to display filtration times that we haven't computed.
\begin{quote} \texttt{>> api.Plex4.createBarcodePlot(filtration\_value\_intervals, 'ripsHouse', \\ % overflow
max\_filtration\_value)} \end{quote}
The files \texttt{ripsHouse\_0.PNG} and \texttt{ripsHouse\_1.PNG} are saved to your current directory.

\begin{figure}[htp]
  \begin{center}
    \subfigure{\includegraphics[width=6in]{ripsHouse_0}}
    \subfigure{\includegraphics[width=6in]{ripsHouse_1}}
   \end{center}
\end{figure}
\FloatBarrier

The second dimensional Betti plot does not appear because there are no $Betti_2$ intervals. Check that these plots are consistent with the Vietoris--Rips definition: edges $[3,5]$ and $[4,5]$ appear at filtration time $t = \sqrt{2}$; the square appears at $t = 2$; the square closes at $t = \sqrt{8}$. \\

%\begin{exercise}
%Change \texttt{ripsHouse} into an explicit stream
%\begin{quote} \texttt{>> ripsExpl = Plex.makeExplicit(ripsHouse);} \end{quote} 
%Check that you can display and edit stream \texttt{ripsExpl} using the methods of Section \ref{explicitStream}. \\
%\end{exercise}

% Is the above exercise no longer necessary, or no longer possible?
% Answer: At the moment it isn't possible. Do you think it is meaningful?

% Is there a way to print the simplices in a stream (and perhaps their filtration times?

{\em Torus example.} Try the following sequence of commands. We start with 400 points from a $20 \times 20$ grid on the unit torus $S^1 \times S^1$ in $\mathbb{R}^4$, and add a small amount of noise to each point.
% If I select points randomly from the torus instead from the regular grid, then the Vietoris--Rips stream does not seem to be able to recover the correct Betti numbers.
We build the Vietoris--Rips stream.
\begin{quote} \texttt{>> max\_dimension = 3; \\
>> max\_filtration\_value = 0.9; \\
>> num\_divisions = 100;
} \end{quote}
Load the file \texttt{pointsTorusGrid.mat}. The matrix \texttt{pointsTorusGrid} appears in your Matlab workspace.
\begin{quote} \texttt{>> load pointsTorusGrid.mat \\
>> point\_cloud = pointsTorusGrid; \\
>> size(point\_cloud) \\
ans = 400\ \ \ 4 \hspace{30mm} \% 400 points in dimension 4 \\
\\
>> stream = api.Plex4.createVietorisRipsStream(point\_cloud, max\_dimension, \\ % overflow
max\_filtration\_value, num\_divisions); \\ 
>> num\_simplices = stream.getSize() \\
num\_simplices = 82479\\
\\
>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(max\_dimension); \\
>> filtration\_index\_intervals = persistence.computeIntervals(stream); \\
>> filtration\_value\_intervals = stream.transform(filtration\_index\_intervals); \\
>> api.Plex4.createBarcodePlot(filtration\_value\_intervals, 'ripsTorus', \\ % overflow
max\_filtration\_value)
} \end{quote}
The files \texttt{ripsTorus\_0.PNG}, \texttt{ripsTorus\_1.PNG} and \texttt{ripsTorus\_2.PNG} are saved to your current directory. We do not show these figures because the plots are very tall. \\

The diameter of this torus (before adding noise) is $\sqrt{8}$, so choosing $t_{max} = 0.9$ likely will not show all homological activity. However, the torus will be reasonably connected by this time. Note the semi-infinite intervals match the correct numbers $Betti_0 = 1$, $Betti_1 = 2$, $Betti_2 = 1$ for a torus.

\begin{quote} \texttt{>> infinite\_barcodes = filtration\_value\_intervals.getInfiniteIntervals(); \\
>> betti\_numbers\_array = infinite\_barcodes.getBettiSequence()
} \end{quote}
\hspace{12mm}\texttt{betti\_numbers\_array =}

\hspace{19mm}$\begin{matrix}
\texttt{1}\\
\texttt{2}\\
\texttt{1}
\end{matrix}$
\vspace{3mm}

This example makes it clear that the computed ``semi-infinite'' intervals do not necessarily persist until $t = \infty$: in a Vietoris--Rips stream, once $t$ is greater than the diameter of the point cloud, the Betti numbers for VR$(Z,t)$ will be $ Betti_0 = 1$, $Betti_1 = Betti_2 = ... = 0$. The computed semi-infinite intervals are merely those that persist until $t = t_{max}$. \\

{\em Remark.} We can build Vietoris--Rips streams not only on top of Euclidean point clouds, but also on top of explicit metric spaces. For example, if \texttt{m\_space} were an explicit metric space, then we could call a command such as
\begin{quote} \texttt{>> stream = api.Plex4.createVietorisRipsStream(m\_space, max\_dimension, \\ % overflow
max\_filtration\_value, num\_divisions); \\ 
} \end{quote}

\begin{exercise}
Slowly increase the values for $t_{max}$, $d_{max}$ and note how quickly the size of the Vietoris--Rips stream and the time of computation grow. Either increasing $t_{max}$ from 0.9 to 1 or increasing $d_{max}$ from 3 to 4 roughly doubles the size of the Vietoris--Rips stream. \\
\end{exercise}

\begin{exercise}
Find a planar dataset $Z \subset \mathbb{R}^2$ and a filtration value $t$ such that VR$(Z,t)$ has nonzero $Betti_2$. Build a Vietoris--Rips stream to confirm your answer. \\
\end{exercise}

\begin{exercise}
Find a planar dataset $Z \subset \mathbb{R}^2$ and a filtration value $t$ such that VR$(Z,t)$ has nonzero $Betti_6$. When building a Vietoris--Rips stream to confirm your answer, don't forget to choose $d_{max} = 7$. \\
\end{exercise}


\subsection{Landmark selection}\label{lands}
For larger datasets, if we include every data point as a vertex, as in the Vietoris--Rips construction, our streams will quickly contain too many simplices for efficient computation. The witness stream and the lazy witness stream address this problem. In building these streams, we select a subset $L \subset Z$, called landmark points, as the only vertices. All data points in $Z$ help serve as witnesses for the inclusion of higher dimensional simplices. \\

There are two common methods for selecting landmark points. The first is to choose the landmarks $L$ randomly from point cloud $Z$. The second is a greedy inductive selection process called sequential maxmin. In sequential maxmin, the first landmark is picked randomly from $Z$. Inductively, if $L_{i-1}$ is the set of the first $i-1$ landmarks, then let the $i$-th landmark be the point of $Z$ which maximizes the function $z \mapsto d(z, L_{i-1})$, where $d(z, L_{i-1})$ is the distance between the point $z$ and the set $L_{i-1}$. \\

Landmarks chosen using sequential maxmin tend to cover the dataset and to be spread apart from each other. A disadvantage is that outlier points tend to be selected. Sequential maxmin landmarks are used in \cite{ac09} and \cite{cidsz08}. \\

The Matlab script corresponding to this section is \texttt{landmark\_example.m}.\\

{\em Figure 8 example.} We create a point cloud of 1,000 points from a figure eight.
\begin{quote} \texttt{>> point\_cloud = examples.PointCloudExamples.getRandomFigure8Points(1000);
} \end{quote}

We create both a random landmark selector and a sequential maxmin landmark selector. These selectors will pick 100 landmarks each.
\begin{quote} \texttt{>> num\_landmark\_points = 100; \\
>> random\_selector = api.Plex4.createRandomSelector(point\_cloud, num\_landmark\_points); \\
>> maxmin\_selector = api.Plex4.createMaxMinSelector(point\_cloud, num\_landmark\_points);
} \end{quote}

We select 100 random landmarks and 100 landmarks via sequential maxmin. Note we need to increment the indices by 1 since Java uses 0-based arrays.
\begin{quote} \texttt{>> random\_points = point\_cloud(random\_selector.getLandmarkPoints() + 1, :); \\
>> maxmin\_points = point\_cloud(maxmin\_selector.getLandmarkPoints() + 1, :);
} \end{quote}

We plot the two sets of landmark points to see the difference between random and sequential maxmin landmark selection.

\begin{quote} \texttt{>> subplot(1, 2, 1); \\
>> scatter(random\_points(:,1), random\_points(:, 2));\\
>> title('Random landmark selection'); \\
>> subplot(1, 2, 2); \\
>> scatter(maxmin\_points(:,1), maxmin\_points(:, 2)); \\
>> title('Maxmin landmark selection');
} \end{quote}

\begin{figure}[htp]
  \begin{center}
    \includegraphics[width=5in]{fig8lands}
   \end{center}
\end{figure}
\FloatBarrier

Sequential maxmin seems to do a better job of choosing landmarks that cover the figure eight and that are spread apart. \\

{\em Remark.} We can select landmark points not only from Euclidean point clouds but also from explicit metric spaces. For example, if \texttt{m\_space} is an explicit metric space, then we may select landmarks using a command such as the following.
\begin{quote} \texttt{>> maxmin\_selector = api.Plex4.createMaxMinSelector(m\_space, num\_landmark\_points); \\
} \end{quote}

Given point cloud $Z$ and landmark subset $L$, we define $\texttt{R} = \max_{z\in Z}\bigl\{d(z,L)\bigr\}$. Number \texttt{R} reflects how finely the landmarks cover the dataset. We often use it as a guide for selecting the maximum filtration value $t_{max}$ for a witness or lazy witness stream. \\

\begin{exercise}
Let $Z$ be the point cloud in Figure \ref{fig:housePointCloud} from Section \ref{euc}, corresponding to the house point cloud. Suppose we are using sequential maxmin to select a set $L$ of 3 landmarks, and the first (randomly selected) landmark is $(1,0)$. Find by hand the other two landmarks in $L$. \\
\end{exercise}

\begin{exercise}
Let $Z$ be a point cloud and $L$ a landmark subset. Show that if $L$ is chosen via sequential maxmin, then for any $l_i,l_j\in L$, we have $d(l_i,l_j)\geq\texttt{R}$. \\
\end{exercise}


\subsection{Witness streams}
Suppose we are given a point cloud $Z$ and landmark subset $L$. Let $m_k(z)$ be the distance from a point $z \in Z$ to its $(k+1)$-th closest landmark point. The witness stream complex $W(Z,L,t)$ is defined as follows.
\begin{itemize}
\item{the vertex set is $L$.}
\item{for $k>0$ and vertices $l_i$, the $k$-simplex $[l_0 l_1 ... l_k]$ is in $W(Z,L,t)$ if all of its faces are, and if there exists a witness point $z \in Z$ such that $$\max\bigl\{d(l_0,z), d(l_1,z), ..., d(l_k,z)\bigr\} \leq t+m_k(z).$$ }
\end{itemize}
Note that $W(Z,L,t) \subset W(Z,L,s)$ whenever $t\leq s$. Note that a landmark point can serve as a witness point. \\

\begin{exercise}
Let $Z$ be the point cloud in Figure \ref{fig:housePointCloud} from Section \ref{euc}, corresponding to the house point cloud. Let $L = \{(1,0),(0,3),(-1,0)\}$ be the landmark subset. Find by hand the filtration time for the edge between vertices $(1,0)$ and $(0,3)$. Which point or points witness this edge? What is the filtration time for the lone 2-simplex $[(1,0),(0,3),(-1,0)]$? \\
\end{exercise}

The Matlab script corresponding to this section is \texttt{witness\_example.m}.\\

{\em Torus example.} Let's build a witness stream instance for 10,000 random points from the unit torus $S^1 \times S^1$ in $\mathbb{R}^4$, with 50 random landmarks.
\begin{quote} \texttt{>> num\_points = 10000; \\
>> num\_landmark\_points = 50; \\
>> max\_dimension = 3; \\
>> num\_divisions = 100; \\
\\
>> point\_cloud = examples.PointCloudExamples.getRandomSphereProductPoints(num\_points, 1, 2); \\ % overflow
>> landmark\_selector = api.Plex4.createRandomSelector(point\_cloud, num\_landmark\_points);
} \end{quote}
The next command returns the landmark covering measure \texttt{R} from Section \ref{lands}.  Often the value for $t_{max}$ is chosen in proportion to \texttt{R}.
\begin{quote} \texttt{>> R = landmark\_selector.getMaxDistanceFromPointsToLandmarks() \\
R = 1.1067 \hspace{40mm} \% Generally close to 1.1 \\
>> max\_filtration\_value = R / 8; \\
} \end{quote}
% TODO: The documentation for getMaxDistanceFromPointsToLandmarks() currently is incorrect.

We create the witness stream.
\begin{quote} \texttt{>> stream = api.Plex4.createWitnessStream(landmark\_selector, max\_dimension, \\ % overflow
max\_filtration\_value, num\_divisions); \\ 
>> num\_simplices = stream.getSize() \\
num\_simplices = 1858 \hspace{40mm} \% Generally close to 2000
} \end{quote}
We plot the Betti intervals.
\begin{quote} \texttt{>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(max\_dimension); \\
>> filtration\_index\_intervals = persistence.computeIntervals(stream); \\
>> filtration\_value\_intervals = stream.transform(filtration\_index\_intervals); \\
>> api.Plex4.createBarcodePlot(filtration\_value\_intervals, 'witnessTorus', \\ % overflow
max\_filtration\_value)
} \end{quote}
The files \texttt{witnessTorus\_0.PNG}, \texttt{witnessTorus\_1.PNG}, and \texttt{witnessTorus\_2.PNG} are saved to your current directory.

\begin{figure}[htp]
  \begin{center}
    \subfigure{\includegraphics[width=6in]{witnessTorus_0}}
    \subfigure{\includegraphics[width=6in]{witnessTorus_1}}
    \subfigure{\includegraphics[width=6in]{witnessTorus_2}}
   \end{center}
\end{figure}
\FloatBarrier

The idea of persistent homology is that long intervals should correspond to real topological features, whereas short intervals are considered to be noise. The plot above shows that for a long range, the torus numbers $Betti_0 = 1$, $Betti_1 = 2$, $Betti_2 = 1$ are obtained. Your plot should contain a similar range. \\

The witness stream above contains approximately 2,000 simplices, fewer than the approximately 80,000 simplices in the Vietoris--Rips stream from the torus example in Section \ref{Vietoris--Rips}. This is despite the fact that we started with a point cloud of 100,000 points in the witness case, but of only 400 points in the Vietoris--Rips case. This supports our belief that the witness stream returns good results at lower computational expense. \\


\subsection{Lazy witness streams}
A lazy witness stream is similar to a witness stream. However, there is an extra parameter $\nu$, typically chosen to be 0, 1, or 2, which helps determine how the lazy witness complexes $LW_\nu(Z,L,t)$ are constructed. See \cite{dsc04} for more information. \\

Suppose we are given a point cloud $Z$, landmark subset $L$, and parameter $\nu\in\mathbb{N}$. If $\nu = 0$, let $m(z) = 0$ for all $z\in Z$. If $\nu >0$, let $m(z)$ be the distance from $z$ to the $\nu$-th closest landmark point. The lazy witness complex $LW_\nu(Z,L,t)$ is defined as follows.
\begin{itemize}
\item{the vertex set is $L$.}
\item{for vertices $a$ and $b$, edge $[ab]$ is in $LW_\nu(Z,L,t)$ if there exists a witness $z \in Z$ such that $$\max\bigl\{d(a,z), d(b,z)\bigr\} \leq t+m(z).$$}
\item{a higher dimensional simplex is in $LW_\nu(Z,L,t)$ if all of its edges are.} 
\end{itemize}
Note that $LW_\nu(Z,L,t) \subset LW_\nu(Z,L,s)$ whenever $t\leq s$. The adjective {\em lazy} refers to the fact that the lazy witness complex is a flag complex: since the 1-skeleton determines all higher dimensional simplices, less computation is involved. \\

\begin{exercise}
Let $Z$ be the point cloud in Figure \ref{fig:housePointCloud} from Section \ref{euc}, corresponding to the house point cloud. Let $L = \{(1,0),(0,3),(-1,0)\}$ be the landmark subset. Let $\nu = 1$. Find by hand the filtration time for the edge between vertices $(1,0)$ and $(0,3)$. Which point or points witness this edge? What is the filtration time for the lone 2-simplex $[(1,0),(0,3),(-1,0)]$? \\
\end{exercise}

\begin{exercise}
Repeat the above exercise with $\nu = 0$ and with $\nu = 2$. \\
\end{exercise}

\begin{exercise}
Check that the 1-skeleton of a witness complex $W(Z,L,t)$ is the same as the 1-skeleton of a lazy witness complex $LW_2(Z,L,t)$. As a consequence, $LW_2(Z,L,t)$ is the flag complex of $W(Z,L,t)$. \\
\end{exercise}

{\em 2-sphere example.} The Matlab script corresponding to this example is \texttt{lazy\_witness\_example.m}.\\

We use parameter $\nu = 1$.
\begin{quote} \texttt{>> max\_dimension = 3; \\
>> num\_points = 1000; \\
>> num\_landmark\_points = 50; \\
>> nu = 1; \\
>> num\_divisions = 100; \\
\\
>> point\_cloud = examples.PointCloudExamples.getRandomSpherePoints(num\_points, max\_dimension - 1); \\ % overflow
>> landmark\_selector = api.Plex4.createRandomSelector(point\_cloud, num\_landmark\_points); \\
} \end{quote}
Often $t_{max}$ is chosen in proportion to \texttt{R}. 
\begin{quote} \texttt{>> R = landmark\_selector.getMaxDistanceFromPointsToLandmarks() \\
R = 0.6877 \hspace{40mm} \% Generally close to 0.7 \\
>> max\_filtration\_value = R; \\
>> stream = streams.impl.LazyWitnessStream(landmark\_selector.getUnderlyingMetricSpace(), landmark\_selector, max\_dimension, max\_filtration\_value, nu, num\_divisions); \\ % Is this method being added to class api?
>> stream.finalizeStream() \\
>> num\_simplices = stream.getSize() \\
num\_simplices = 79842 \hspace{40mm} \% Generally between 30000 and 180000\\
>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(max\_dimension); \\
>> filtration\_index\_intervals = persistence.computeIntervals(stream); \\
>> filtration\_value\_intervals = stream.transform(filtration\_index\_intervals); \\
>> api.Plex4.createBarcodePlot(filtration\_value\_intervals, 'lazySphere', \\ % overflow
max\_filtration\_value) \\
} \end{quote}
The files \texttt{lazySphere\_0.PNG}, \texttt{lazySphere\_1.PNG}, and \texttt{lazySphere\_2.PNG} are saved to your current directory.

\begin{figure}[htp]
  \begin{center}
    \subfigure{\includegraphics[width=6in]{lazySphere_0}}
    \subfigure{\includegraphics[width=6in]{lazySphere_1}}
    \subfigure{\includegraphics[width=6in]{lazySphere_2}}
   \end{center}
\end{figure}
\FloatBarrier

In the next section we build a lazy witness stream on a dataset of range image patches. \\




\section{Example with real data}\label{real}

We now do an example with real data. The corresponding Matlab script is \texttt{image\_patch\_example.m}, and it relies on the files \texttt{pointsRange.mat} and \texttt{dct.m}. \\

In {\em On the nonlinear statistics of range image patches} \cite{ac09}, we study a space of range image patches drawn from the Brown database \cite{lpm03}. A range image is like an optical image, except that each pixel contains a distance instead of a grayscale value. Our space contains high-contrast, normalized, $5 \times5$ pixel patches. We write each $5\times5$ patch as a vector with 25 coordinates and think of our patches as point cloud data in $\mathbb{R}^{25}$. We select from this space the 30\% densest vectors, based on a density estimator called $\rho_{300}$ (see Appendix \ref{A:core}). In \cite{ac09} this dense core subset is denoted $X^5(300,30)$, and it contains 15,000 points. In the next example we verify a result from \cite{ac09}: $X^5(300,30)$ has the topology of a circle. \\

Load the file \texttt{pointsRange.mat}. The matrix \texttt{pointsRange} appears in your Matlab workspace.
\begin{quote} \texttt{>> load pointsRange.mat \\
>> size(pointsRange) \\ 
ans = 15000\ \ \ 25 \hspace{19mm} \% 15000 points in dimension 25
} \end{quote}
Matrix \texttt{pointsRange} is in fact $X^5(300,30)$: each of its rows is a vector in $\mathbb{R}^{25}$. Display some of the coordinates of \texttt{pointsRange}. It is not easy to visualize a circle by looking at these coordinates! \\

We pick 50 sequential maxmin landmark points, we find the value of \texttt{R}, and we build the lazy witness stream with parameter $\nu = 1$. 

\begin{quote} \texttt{>> max\_dimension = 3; \\
>> num\_landmark\_points = 50; \\
>> nu = 1; \\
>> num\_divisions = 500; \\
\\
>> landmark\_selector = api.Plex4.createMaxMinSelector(pointsRange, num\_landmark\_points); \\
>> R = landmark\_selector.getMaxDistanceFromPointsToLandmarks() \\ 
R = 0.7759 \hspace{28mm} \% Generally close to 0.75 \\
>> max\_filtration\_value = R / 3; \\
>> stream = streams.impl.LazyWitnessStream(landmark\_selector.getUnderlyingMetricSpace(), landmark\_selector, max\_dimension, max\_filtration\_value, nu, num\_divisions); \\ % overflow
>> stream.finalizeStream() \\
>> num\_simplices = stream.getSize() \\
num\_simplices = 12036 \hspace{26mm} \% Generally between 10000 and 25000\\
\\
>> persistence = api.Plex4.getDefaultSimplicialAlgorithm(max\_dimension); \\
>> filtration\_index\_intervals = persistence.computeIntervals(stream); \\
>> filtration\_value\_intervals = stream.transform(filtration\_index\_intervals); \\
>> api.Plex4.createBarcodePlot(filtration\_value\_intervals, 'lazyRange', \\ % overflow
max\_filtration\_value)
} \end{quote}
The files \texttt{lazyRange\_0.PNG} and \texttt{lazyRange\_1.PNG} (and maybe \texttt{lazyRange\_2.PNG}) are saved to your current directory.

\begin{figure}[htp]
  \begin{center}
    \subfigure{\includegraphics[width=6in]{lazyRange_0}}
    \subfigure{\includegraphics[width=6in]{lazyRange_1}}
   \end{center}
  \caption{Betti intervals for the lazy witness complex built from $X^5(300,30)$}
  \label{fig:rangeBetti}
\end{figure}
\FloatBarrier

The plots above show that for a long range, the circle Betti numbers $Betti_0 = Betti_1 = 1$ are obtained. Your plot should contain a similar range. This is good evidence that the core subset $X^5(300,30)$ is well-approximated by a circle. \\

Our $5\times 5$ normalized patches are currently in the pixel basis: every coordinate corresponds to the range value at one of the 25 pixels. The Discrete Cosine Transform (DCT) basis is a useful basis for our patches \cite{ac09, lpm03}. We change to this basis in order to plot a projection of the loop evidenced by Figure \ref{fig:rangeBetti}. The method \texttt{dct.m} returns the DCT change-of-basis matrix for square patches of size specified by the input parameter.
\begin{quote} \texttt{>> pointsRangeDct = pointsRange $^*$ dct(5);
%>> size(pointsRangeDct)\\
%ans = 15000\quad 24 \hspace{30mm} \% 15000 points in DCT basis (representation)
} \end{quote}

Two of the DCT basis vectors are horizontal and linear gradients.

\vspace{-3mm}
\begin{figure}[htb]
	\centering
	\includegraphics[width=2in]{linearGrad}
\end{figure}
\vspace{-3mm}
\FloatBarrier

We plot the projection of \texttt{pointsRangeDct} onto the linear gradient DCT basis vectors.
\begin{quote} \texttt{>> plot(pointsRangeDct(:,1), pointsRangeDct(:,5), '.') \\
axis square
} \end{quote}

\begin{figure}[htp]
  \begin{center}
    \subfigure[Projection of $X^5(300,30)$]{\includegraphics[width=3.0in]{r5k300c30}}
    \quad
    \subfigure[Range primary circle]{\includegraphics[width=2.9in]{primaryCircle}}
   \end{center}
\end{figure}
\FloatBarrier

The projection of $X^5(300,30)$ in Figure (a) shows a circle. It is called the range primary circle and is parameterized as shown in Figure (b).




\section{Remarks} 


\subsection{Matlab functions with javaPlex commands}
Writing Matlab functions is very useful. In order to include javaPlex commands in an m-file function, include the command \texttt{import edu.stanford.math.plex4.*;} as the second line of the function ---  that is, as the first line underneath the function header. We include the m-file \texttt{eulerCharacteristic.m} as an example Matlab function.\\

{\em Euler characteristic example.}
The corresponding Matlab script is \texttt{euler\_characteristic\_example.m}, and it relies on the file \texttt{eulerCharacteristic.m}. \\

First we create a 6-dimensional sphere. 
\begin{quote} \texttt{>> dimension = 6; \\
>> stream = api.Plex4.createExplicitSimplexStream(); \\
>> stream.addElement(0:(dimension + 1)); \\
>> stream.ensureAllFaces(); \\
>> stream.removeElementIfPresent(0:(dimension + 1)); \\
>> stream.finalizeStream();
} \end{quote}
The function \texttt{eulerCharacteristic.m} accepts an explicit simplex stream and its dimension as input. The function demonstrates two different methods for computing the Euler characteristic.
\begin{quote} \texttt{>> eulerCharacteristic(stream, dimension) \\
The Euler characteristic is 2 = 8 - 28 + 56 - 70 + 56 - 28 + 8, using the alternating sum of cells.\\
The Euler characteristic is 2 = 1 - 0 + 0 - 0 + 0 - 0 + 1, using the alternating sum of Betti numbers.
} \end{quote}


\subsection{Representative cycles}
The persistence algorithm that computes barcodes can also find a representative cycle for each homology class. 
%The current version of JPlex does not return representative cycles, though development versions of JPlex can. 
% Andrew, what's the status for representative cycles in javaPlex? I saw you had a file "representatives_example.m" but without any relevant code inside it.
However, there is no guarantee that the produced representative will be geometrically nice. 


%\subsection{Java heap size}
%Depending on the size of your javaPlex computations, you may need to increase the maximum Java heap size. This should not be necessary for the examples in this tutorial. \\

%The following command returns your maximum heap size in bytes.
%\begin{quote} \texttt{>> java.lang.Runtime.getRuntime.maxMemory \\
%ans = 130875392
%} \end{quote}
%My computer has a heap limit of approximately 128 megabytes. To increase your limit to, say, 256 megabytes, create a file named \texttt{java.opts} in your Matlab directory which contains the text \texttt{-Xmx256m} and then restart Matlab.


%\subsection{From Java variables to Matlab variables}
%Some javaPlex commands return Java variables, when instead one might want output in the form of a Matlab variable, such as a matrix of numbers. One way to transform Java variables into Matlab variables is by using an m-file. For instance, in Section ?? %\ref{explicitStream} 
% no
%we used the m-file \texttt{interval2mat.m} to take an array of type PersistenceInterval into a Matlab matrix. Similarly, the m-file \texttt{betti2mat.m} accepts input of type \texttt{Plex.BettiNumbers} and returns a Matlab vector of integers. These commands are typically used as shown below, where \texttt{intervals} is an array of type PersistenceInterval.

%\begin{quote} \texttt{>> intervalMatrix = interval2mat(intervals); \\
%>> bettiVect = betti2vect(Plex.FilterInfinite(intervals)); \\
%} \end{quote}




\appendix
\appendixpage
\addappheadtotoc




\section{Dense core subsets}\label{A:core}

A core subset of a dataset is a collection of the densest points, such as $X^5(300,30)$ in Section \ref{real}. Since there are many density estimators, and since we can choose any number of the densest points, a dataset has a variety of core subsets. In this appendix we discuss how to create core subsets. \\

Real datasets can be very noisy, and outlier points can signicantly alter the computed topology. Therefore, instead of trying to approximate the topology of an entire dataset, we often proceed as follows. We create a family of core subsets and identify their topologies. Looking at a variety of core subsets can give a good picture of the entire dataset. \\

See \cite{cidsz08, dsc04} for an example using multiple core subsets. The dataset contains high-contrast patches from natural images. The authors use three density estimators. As they change from the most global to the most local density estimate, the topologies of the core subsets change from a circle, to three intersecting circles, to a Klein bottle. \\

One way to estimate the density of a point $z$ in a point cloud $Z$ is as follows. Let $\rho_k(z)$ be the distance from $z$ to its $k$-th closest neighbor. Let the density estimate at $z$ be $\frac{1}{\rho_k(z)}$. Varying parameter $k$ gives a family of density estimates. Using a small value for $k$ gives a local density estimate, and using a larger value for $k$ gives a more global estimate. \\

For Euclidean datasets, one can use the m-file \texttt{kDensitySlow.m} to produce density estimates $\frac{1}{\rho_k}$. The following command is typical.
\begin{quote} \texttt{>> densities = kDensitySlow(points, $k$); 
} \end{quote}
Input \texttt{points} is an $N\times n$ matrix of $N$ points in $\mathbb{R}^n$. Input $k$ is the density estimate parameter. Output \texttt{densities} is a vertical vertex of length $N$ containing the density estimate at each point. \\

M-file \texttt{coreSubset.m} builds a core subset. The following command is typical.
\begin{quote} \texttt{>> core = coreSubset(points, densities, numPoints); 
} \end{quote}
Inputs \texttt{points} and \texttt{densities} are as above. Output \texttt{core} is a $\texttt{numPoints}\times n$ matrix representing the \texttt{numPoints} densest points. \\

{\em Prime numbers example.} The Matlab script corresponding to this example is \texttt{core\_subsets\_example.m}.\\

The command \texttt{primes(3571)} returns a vector listing all prime numbers less than or equal to 3571, which is the 500-th prime. We think of these primes as points in $\mathbb{R}$ and build the core subset of the 10 densest points with density parameter $k = 1$.
\begin{quote} \texttt{>> p = primes(3571)'; \\
>> length(p) \\
ans = 500 \\
>> densities1 = kDensitySlow(p, 1); \\
>> core1 = coreSubset(p, densities1, 10) \\
core1 =
} \end{quote}

\hspace{15mm} \texttt{2}

\hspace{15mm} \texttt{3}

\hspace{15mm} \texttt{5}

\hspace{15mm} \texttt{7}

\hspace{15mm} \texttt{11}

\hspace{15mm} \texttt{13}

\hspace{15mm} \texttt{17}

\hspace{15mm} \texttt{19}

\hspace{15mm} \texttt{29}

\hspace{15mm} \texttt{31} \\
We get a bunch of twin primes, which makes sense since $k = 1$. Let's repeat with $k = 50$.
\begin{quote} \texttt{>> densities50 = kDensitySlow(p, 50); \\
>> core50 = coreSubset(p, densities50, 10) \\
core50 =
} \end{quote}

\hspace{15mm} \texttt{113}

\hspace{15mm} \texttt{127}

\hspace{15mm} \texttt{109}

\hspace{15mm} \texttt{131}

\hspace{15mm} \texttt{107}

\hspace{15mm} \texttt{137}

\hspace{15mm} \texttt{139}

\hspace{15mm} \texttt{157}

\hspace{15mm} \texttt{149}

\hspace{15mm} \texttt{151} \\
With $k = 50$, we expect the densest points to be slightly larger than the 25-th prime, which is 97. \\

{\em Note:} As its name suggests, the m-file \texttt{kDensitySlow.m} is not the most efficient way to calculate $\rho_k$ for large datasets. There is a faster file \texttt{kDensity.m} for this purpose, which uses the kd-tree data structure. It is not included in the tutorial because it requires one to download a kd-tree package for Matlab, available at \url{http://www.mathworks.com/matlabcentral/fileexchange/21512-kd-tree-for-matlab}. Please email \texttt{henrya@math.stanford.edu} if you're interested in using \texttt{kDensity.m}.

% What are the differences in timings between fast and slow versions?
% It seems that k=300 is surprisingly slow with kDensity.m: 1108 seconds. Slower than kDensitySlow.m. Double check?

%I typically use the m-file \texttt{kDensitySlow.m} on datasets of around 50,000 points (for instance, $X^5(300,30)$ in Section \ref{real} is the 30\% densest points from a set of size 50,000, using the density estimate $\rho_{300}$). This computation takes about 10 minutes on my MacBook, which is much longer than any of the computations I do using the JPlex software. \\ % Elapsed time is 432.024880 seconds, 7-17-09. This was effectively kDensitySlow.m, I think




\begin{thebibliography}{9}

\bibitem{ac09}
{\sc H.~Adams and G.~Carlsson}, {\em On the nonlinear statistics of range image patches}, SIAM J. Img. Sci., 2, (2009), pp.~110-117.
	
\bibitem{a83}
{\sc M.~A.~Armstrong}, {\em Basic Topology}, Springer, New York, Berlin, 1983.

\bibitem{cidsz08}
{\sc G.~Carlson, T.~Ishkhanov, V.~de Silva, and A.~Zomorodian}, {\em On the local behavior of spaces of natural images}, Int. J. Computer Vision, 76 (2008), pp.~1--12.

\bibitem{dsc04}
{\sc V.~de Silva and G.~Carlsson}, {\em Topological estimation using witness complexes}, in Proceedings of the Symposium on Point-Based Graphics, ETH, Z\"urich, Switzerland, 2004, pp.~157--166.

\bibitem{eh10}
{\sc H.~Edelsbrunner and J.~Harer}, {\em Computational Topology: An Introduction}, American Mathematical Society, Providence, 2010.

\bibitem{elz02}
{\sc H.~Edelsbrunner, D.~Letscher, and A.~Zomorodian}, {\em Topological persistence and simplification},  Discrete Computat. Geom., 28 (2002), pp.~511--533.

\bibitem{h02}
{\sc A.~Hatcher}, {\em Algebraic Topology}, Cambridge University Press, Cambridge, UK, 2002.

\bibitem{lpm03}
{\sc A.~B.~Lee, K.~S.~Pedersen, and D.~Mumford}, {\em The nonlinear statistics of high-contrast patches in natural images}, Int. J. Computer Vision, 54 (2003), pp.~83--103.

\bibitem{jplex}
{\sc H.~Sexton and M.~Vejdemo-Johansson}, JPlex simplicial complex library. \url{http://comptop.stanford.edu/programs/jplex/}.

\bibitem{zc05}
{\sc A. Zomorodian and G. Carlsson}, {\em Computing persistent homology}, Discrete Computat. Geom., 33 (2005), pp.~247--274. 

\end{thebibliography}

\end{document}
